# -*- encoding: utf-8 -*-

# 顶点（节点，交点）
#   邻接：（u,v） 顶点v与顶点u邻接

# 边（链接）
#   权重
#   方向
#   关联：（u,v）从顶点u关联到v，或者相反，但是在有向图中两个顶点间边不一定是对称的，有去无回是完全有可能的。
#       入度，出度：无向图中，顶点的度就是与顶点相关联的边的数目
#                 有向图中，指向顶点的边的数目和非指向顶点的边数目分别为顶点的入度和出度

# 路   径：依次遍历顶点序列之间的边所形成的轨迹。注意，依次就意味着有序，先1后2和先2后1不一样
# 简单路径：没有重复顶点的路径称为简单路径。说白了，这一趟路里没有出现绕了一圈回到同一点的情况，也就是没有环。

# 环
# 网
# 圈
# 二分图
# 单向图
# 无向完全图
# DAG：很多动态规划的问题都可以转化成DAG中的最长路径、最短路径或者路径计数的问题

# 连通的：无向图中每一对不同的顶点之间都有路径。
# 强连通的：有向图里每一对不同的顶点之间都有路径，
# 弱连通的：将有向图的方向忽略后，任何两个顶点之间总是存在路径
# 强连通分支：有向图的子图是强连通的，且不包含在更大的连通子图中

# 关节点(割点)：某些特定的顶点对于保持图或连通分支的连通性有特殊的重要意义，如果移除该顶点将使图或者分支失去连通性
# 双连通图：不含任何关节点的图。
#         如果你想要破坏互联网，你就应该找到它的关节点。同样，要防范敌人的攻击，首要保护的也应该是关节点。
#         在资源总量有限的前提下，找出关节点并给予特别保障，是提高系统整体稳定性和鲁棒性的基本策略。

# 桥(割边)：和关节点类似，删除一条边，就产生比原图更多的连通分支的子图，这条边就称为割边或者桥。

# 顶点的集合
# 顶点通过边结对

# 图算法（比如广度优先搜索 或者 深度优先搜索）

# 图的描述
#   邻接列表：
#       每一个顶点会存储一个从它这里开始的边的列表，邻接列表只描述了指向外部的边。
#       查找两个顶点之间的边或者权重会比较费时，因为遍历邻接列表直到找到为止
#   邻接矩阵：
#       行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连、如果相连这个值表示的是相连边的权重
#       往邻接矩阵中添加顶点的成本非常昂贵，因为新的矩阵结果必须重新按照新的行/列创建，再将已有的数据复制到新的矩阵中。

"""
假设 V 表示图中顶点的个数，E 表示边的个数。

    操作	    邻接列表	    邻接矩阵
------------------------------------------
  存储空间	    O(V + E)	    O(V^2)
  添加顶点	      O(1)	        O(V^2)
  添加边	     O(1)	        O(1)
  检查相邻性	  O(V)	         O(1)

"""


"""

"""



from typing import List, TypeVar

T = TypeVar("T")



class Edge(object):
    pass


class Node(object):
    pass


class Node(object):
    def __init__(self, value):
        self.value = value      # 节点值
        self.come = 0           # 节点入度
        self.out = 0            # 节点出度
        self.nexts = []         # 节点的邻居节点
        self.edges = []         # 在节点为from的情况下，边的集合


class Edge(object):
    def __init__(self, weight, fro, to):
        self.weight = weight    # 边的权重
        self.fro = fro          # 边的from节点
        self.to = to            # 边的to节点


class Graph(object):
    def __init__(self):
        self.nodes = {}         # 图的所有节点集合  字典形式：{节点编号：节点}
        self.edges = []         # 图的边集合

